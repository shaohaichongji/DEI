# SS_LightProtocolFactory 使用说明书（STRING / BYTE）

> 目标：用一套 YAML/Rule 配置，把 `cmd_template` 里的 `<placeholder>` 按规则替换成**字符串命令**（STRING 模式）或按顺序拼成**字节流命令**（BYTE 模式 pipeline）。

---

## 1. 核心概念

### 1.1 两种构建模式

#### STRING 模式：`BuildCommand(...)`

- `cmd_template` 是一个字符串模板，例如：  
    `SET CH <channel> VAL <value>`
    
- 解析模板中出现的 `<xxx>`，每个 `<xxx>` 找到对应 `placeholders[xxx]` 规则：
  
    1. `source` 取原始值 `raw_value`
       
    2. `parser_tool` 对 `raw_value` 做字符串变换 → `final_value`
       
    3. 用 `final_value` 替换模板中的 `<xxx>`
    
- 输出：`out_cmd`（最终字符串）
  

#### BYTE 模式：`BuildBytesCommand(...)`

- `cmd_template` 的 **核心意义变了**：不再“替换回字符串”，而是“定义拼包顺序”。
  
- 解析模板时按顺序扫描：
  
    - 普通文本段：当作 hex 字符串解析为字节（可选，通常你模板里不会写普通段）
      
    - `<xxx>`：找到 `placeholders[xxx]`，按规则生成字节并**append 到 out_bytes**
    
- 输出：`out_bytes`（最终 byte buffer）
  

> 旧逻辑升级版：**模板决定拼接顺序，placeholder 决定每段如何生成 bytes**。

---

## 2. placeholder rule 字段解释（配置 YAML 时用）

`SS_LightPlaceholderRule` 关键字段（按你当前实现）：

- `source`: 决定该 placeholder 的原始输入值从哪里来
  
- `parser_tool`: 决定用哪个工具处理原始输入值
  
- `extra_param`: 工具的额外参数（字符串数组）
  
- `endian`: BYTE 模式下传给 bytes 工具（大端/小端）
  

### 2.1 source 支持值（ResolveSourceValue）

|source 值|raw_value 的来源|说明|
|---|---|---|
|`param_value`|传入的 `param_value_str`|例如设置亮度值、开关状态|
|`channel_num`|`channel_index + 1`|1-based，兼容 A=1..Z=26 这种|
|`channel_index`|`channel_index`|0-based，极少数设备需要|
|`empty` / 空字符串|`""`|通常配合 GetRawData（固定字节）这种工具|

> 如果 source 写错或不支持，会直接失败（out_error）。

---

## 3. STRING 工具函数说明（ToolXXX -> string）

### 3.1 ToolDoNothing

**签名：**

```cpp
static std::string ToolDoNothing(std::string_view input, const std::vector<std::string>& extra_param);
```

**作用：**  
返回 `input`（会 Trim）。

**extra_param：** 不使用。

**适用：**

- 你已经把值准备好了，不需要转换
  
- 占位符只是把参数原样塞进命令里
  

**例：**

```yaml
<value>:
  source: param_value
  parser_tool: DoNothing
```

---

### 3.2 ToolNumberToUpperAlpha

**作用：** 把 1..26 转成字母 A..Z / a..z

**输入：**

- `input`: 十进制数字字符串，范围必须 1..26
  
- `extra_param[0]`: `"true"` 表示大写，`"false"` 表示小写（大小写不敏感）
  

**输出：**

- 单字符字符串 `"A"`..`"Z"` 或 `"a"`..`"z"`
  
- 任何非法输入会抛异常（由 ApplyPlaceholderRuleString 捕获为 out_error）
  

**例：**

```yaml
<channel>:
  source: channel_num
  parser_tool: NumberToUpperAlpha
  extra_param: ["true"]
```

---

### 3.3 ToolNumberToFixedDec

**作用：** 数字字符串补零到指定宽度（保留符号位）

**输入：**

- `input`: 有符号十进制字符串（可带 +/-）
  
- `extra_param[0]`: 目标宽度（>=0），只对数字部分生效
  

**输出：**

- 宽度足够：原值（trim 后）
  
- 不够：在数字部分左侧补 `0`
  

**例：**

- input="7", width=3 -> "007"
  
- input="-7", width=3 -> "-007"
  

**YAML：**

```yaml
<id>:
  source: param_value
  parser_tool: NumberToFixedDec
  extra_param: ["4"]
```

---

### 3.4 ToolGetStringMapValue

**作用：** 做一个字符串映射表，返回 `< >` 内的 value

**输入：**

- `input`: key（比如 `"true"` `"false"`）
  
- `extra_param`: 每项形如 `"文本<值>"`，例如：
  
    - `"true<H>"`
      
    - `"false<L>"`
      

**输出：**

- 找到 `label == input`（大小写不敏感）→ 返回 `<>` 内的内容
  
- 找不到 → 抛异常
  

**例：**

```yaml
<level>:
  source: param_value
  parser_tool: GetStringMapValue
  extra_param:
    - "true<H>"
    - "false<L>"
```

---

### 3.5 ToolDigitalCharacterCalculation

**作用：** 对十进制整数做运算（加减乘除模）

**输入：**

- `input`: lhs（十进制整数）
  
- `extra_param[0]`: rhs（十进制整数）
  
- `extra_param[1]`: operator（不区分大小写）：
  
    - `"add"` `"subtract"` `"multiply"` `"divide"` `"modulo"`
      

**输出：**

- 运算结果的十进制字符串
  

**注意：**

- 除数 0 会抛异常
  
- 目前实现没做溢出保护（你旧版做了 safe_add/safe_mul 那套更严谨）
  

**例：**

```yaml
<addr>:
  source: channel_num
  parser_tool: DigitalCharacterCalculation
  extra_param: ["16", "add"]     # addr = channel_num + 16
```

---

## 4. BYTE 工具函数说明（ToolXXX -> bytes pipeline）

BYTE 工具遵循一个共同约定：

```cpp
bool ToolX(std::string_view input,
           const std::vector<std::string>& extra_param,
           std::vector<uint8_t>& out_bytes,
           bool endian);
```

- `input`：来自 source 的 raw_value
  
- `extra_param`：来自 YAML
  
- `out_bytes`：**追加**（append），不清空
  
- `endian`：
  
    - true: 大端（高字节在前）
      
    - false: 小端（低字节在前）
      

---

### 4.1 HexStringToBytes

**作用：** 把 hex 字符串解析为 bytes（工具内部使用为主）

**支持输入格式：**

- `"0x0010"`
  
- `"00 10"`
  
- `"00,10"`
  
- `"00_10"`
  
- `"0010"`
  

**规则：**

- 过滤掉非 hex 字符
  
- 奇数长度自动左补 `0`
  

**例：**

- `"0xA"` -> `[0x0A]`
  
- `"0010"` -> `[0x00, 0x10]`
  

---

### 4.2 ToolGetRawData

**作用：** 直接把 `extra_param[0]` 里的 hex 追加到 out_bytes（固定字节段）

**输入：**

- `extra_param[0]`: hex 字符串
  
- `input` 不使用
  
- `endian` 不使用
  

**例：**

```yaml
<FunctionCode>:
  source: empty
  endian: true
  parser_tool: GetRawData
  extra_param: ["0x06"]
```

输出追加：`06`

---

### 4.3 ToolByteConversion

**作用：** base(hex) + inc(dec) → 按指定字节宽度编码追加

**extra_param：**

- `extra_param[0]`：字节数 bytes（1..8）
  
- `extra_param[1]`：base_hex（十六进制，可为空=0）
  
- `extra_param[2]`：inc_dec（十进制，若 input 为空才用它）
  

**input：**

- 优先作为 inc（十进制字符串）
  
- 若 input 为空才用 extra_param[2]
  

**endian：**

- true：大端写入
  
- false：小端写入
  

**典型用途：**

- 地址 = base + channel_offset
  
- 值 = base + param_value
  

**例：**

```yaml
<RegisterAddress>:
  source: channel_num
  endian: true
  parser_tool: ByteConversion
  extra_param:
    - "2"         # 2 bytes
    - "0x0010"    # base
    - "0"         # fallback inc
```

若 channel_num=1 → inc=1 → sum=0x0011 → 大端追加：`00 11`

---

### 4.4 ToolGetStringMapValueToBytes

**作用：** 字符串映射到 hex，再解析为 bytes 追加

**输入：**

- `input`: key（比如 `"常亮"` `"关闭"` `"true"`）
  
- `extra_param`: 每项形如 `"文本<0x0000>"`
  

**endian：**

- true：按 hex 顺序追加（大端）
  
- false：反序追加（小端）
  

**例：**

```yaml
<Mode>:
  source: param_value
  endian: true
  parser_tool: GetStringMapValueToBytes
  extra_param:
    - "常亮<0x0001>"
    - "关闭<0x0000>"
```

param_value="常亮" → 追加 `00 01`

---

## 5. BYTE 模式模板（pipeline）写法规范

### 5.1 最常见写法（只有 placeholder，没有普通段）

```yaml
cmd_template: "<DeviceAddress><FunctionCode><RegisterAddress><RegisterValue><Subfunction>"
```

解析过程：

- 遇到 `<DeviceAddress>`：按 rule 生成 bytes append
  
- 遇到 `<FunctionCode>`：append
  
- ...
  
- 最终 out_bytes = 所有片段拼起来
  

### 5.2 如果模板里夹了普通文本段

你现在实现会把普通段当“hex 文本”解析（AppendHexBytesFromText）。  
所以这玩意能工作：

```yaml
cmd_template: "AA55 <Value> 0D0A"
```

但建议别这么搞，容易把同事搞疯。

---

## 6. 整包处理（CRC / MBAP）

### 6.1 CalculateCRC（Modbus RTU）

```cpp
static bool CalculateCRC(std::vector<uint8_t>& pdu_bytes, bool is_be);
```

- 输入：`pdu_bytes`（一般含 Address + PDU）
  
- 输出：在末尾追加 CRC16 两字节
  
- `is_be=false`：低字节在前（标准 RTU）
  
- `is_be=true`：高字节在前（非标准，除非设备要求）
  

**典型用法：**

- BuildBytesCommand 得到 `[addr][func][data...]`
  
- 发送前：`CalculateCRC(bytes, false);`
  

### 6.2 CalculateMBAP（Modbus TCP）

```cpp
static bool CalculateMBAP(std::vector<uint8_t>& pdu_bytes, const std::vector<uint8_t>& unit_identifier);
```

- 输入：`pdu_bytes`（PDU，不含 MBAP）
  
- unit_identifier：必须 1 字节
  
- 输出：把 MBAP(7 bytes) + PDU 组成 ADU 覆盖回 pdu_bytes
  
- 内部 txid 自增（非线程安全）
  

**典型用法：**

- BuildBytesCommand 得到 PDU
  
- 发送前：`CalculateMBAP(bytes, {0x01});`
  

---

## 7. 常见坑

1. **channel_num 是否 1-based**
   
    - 现在是 `channel_index + 1`，这是对的（兼容字母映射、寄存器偏移）
      
    - 某些设备要 0-based 就用 channel_index
    
2. **GetRawData + source**
   
    - source 写 `empty` 或空字符串就行
      
    - 别把 param_value 塞进去然后说“为啥 GetRawData 不用 input”，因为它本来就不该用
    
3. **ByteConversion 的 inc 只能是十进制**
   
    - input="0x10" 会直接炸（因为 parse_dec）
      
    - 需要 hex inc 就自己扩展工具（或者先 string tool 转十进制再走 ByteConversion）
    
4. **ToolDigitalCharacterCalculation 目前没防溢出**
   
    - 如果你要严谨，照搬你旧版 safe_add/safe_mul 那套回来
    
5. **endian 的语义**
   
    - ByteConversion / MapValueToBytes：endian=true 大端，false 小端
      
    - GetRawData：无视 endian（它就是 raw bytes）
    
6. **模板普通段解析**
   
    - AppendHexBytesFromText 会把普通文本中所有 hex 字符都捞出来
      
    - 所以 `"HELLO"` 这种会报错（没 hex），别写这种模板
      

---

## 8. 最小配置示例

### 8.1 STRING 模式最小例子

```yaml
cmd_template: "CH=<channel> VAL=<value>"
placeholders:
  channel:
    source: channel_num
    parser_tool: DoNothing
    extra_param: []
  value:
    source: param_value
    parser_tool: DoNothing
    extra_param: []
```

channel_index=0, param_value="128" → `CH=1 VAL=128`

---

### 8.2 BYTE 模式最小例子（示例）

```yaml
cmd_template: "<DeviceAddress><FunctionCode><RegisterAddress><RegisterValue><Subfunction>"
placeholders:
  DeviceAddress:
    source: empty
    endian: true
    parser_tool: GetRawData
    extra_param: ["0x01"]

  FunctionCode:
    source: empty
    endian: true
    parser_tool: GetRawData
    extra_param: ["0x06"]

  RegisterAddress:
    source: channel_num
    endian: true
    parser_tool: ByteConversion
    extra_param: ["2", "0x0010", "0"]

  RegisterValue:
    source: param_value
    endian: true
    parser_tool: ByteConversion
    extra_param: ["2", "0x0000", "0"]

  Subfunction:
    source: empty
    endian: true
    parser_tool: GetRawData
    extra_param: ["0x02"]
```

channel_index=0（channel_num=1），param_value="5" →  
bytes：`01 06 00 11 00 05 02`

之后如果 RTU：再 `CalculateCRC(bytes,false)`。

---